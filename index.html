<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .placeholder {
        font-size: 14px;
        padding: 0.2rem;
        border-radius: 0.2rem;
        background-color: #0000ff30;
        cursor: pointer;
      }

      .placeholder.active {
        border: 1px dotted green;
      }

      .placeholder::before {
        content: "{} ";
        font-size: 12px;
      }

      .container {
        display: flex;
        gap: 1rem;
        align-items: stretch;
        height: 50vh;
        width: 100%;
        margin-top: 3rem;
      }

      .container > * {
        flex: 1 0 320px;
      }

      #editor {
        border: 1px solid #242443;
        border-radius: 0.2rem;
        position: relative;
      }

      #editor::before {
        content: "Editor";
        position: absolute;
        top: -5%;
        left: 0;
        font-weight: 600;
      }

      #placeholders {
        position: relative;
      }

      #placeholders::before {
        content: "Placeholders";
        position: absolute;
        top: -5%;
        left: 0;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div contenteditable="true" id="editor"></div>
      <div id="placeholders"></div>
    </div>
    <script src="https://unpkg.com/mustache@latest"></script>
    <script>
      const BRACES_COUNT = 4;
      const editor = document.querySelector("#editor");
      const placeholders = document.querySelector("#placeholders");
      const content = {
        template: "",
        placeholders: [],
      };

      editor.addEventListener("input", (ev) => {
        const value = ev.target.innerHTML;
        let cursorPosition = getCursorPositionRelativeToText(editor);
        if (triggerPlaceholder(value)) {
          cursorPosition = cursorPosition - BRACES_COUNT;
        }
        try {
          content.placeholders.push(...Mustache.parse(value));
        } catch (error) {
          console.warn(error.message);
        }
        renderFormFields();
        editor.innerHTML = content.template;
        setCursorAtNodePosition(editor, cursorPosition);
      });

      function renderFormFields() {
        placeholders.innerHTML = "";
        if (content.placeholders.length === 0) return;
        const nodes = [];
        const fields = content.placeholders
          .filter((item) => item[0] === "name")
          .map((item) => ({ title: item[1] }));
        for (const field of fields) {
          const label = document.createElement("label");
          const input = document.createElement("input");
          input.addEventListener("click", (ev) => {
            const value = ev.target.value;
          });
          input.type = "text";
          label.textContent = field.title;
          label.append(input);
          label.style =
            "display: flex; flex-direction: column; text-transform: capitalize;";
          nodes.push(label);
        }
        placeholders.append(...nodes);
      }

      editor.addEventListener("click", (ev) => {
        if (
          ev.target instanceof HTMLSpanElement &&
          ev.target.getAttribute("class").includes("placeholder")
        ) {
          const span = ev.target;
          span.classList.add("active");
        }
      });

      const triggerPlaceholder = (text) => {
        content.template = text;
        let isPlaceholderAdded = false;
        const withplaceholders = text.replace(/{{(.+)}}/g, (value) => {
          isPlaceholderAdded = true;
          const letters = value.match(/\w/g).join("");
          return `<span contenteditable='false' class='placeholder'>${letters}</span>`;
        });
        content.template = withplaceholders;
        return isPlaceholderAdded;
      };

      function getCursorPositionRelativeToText(editableElem) {
        const selection = window.getSelection();
        let currentPos = 0;

        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const preCaretRange = range.cloneRange();
          preCaretRange.selectNodeContents(editableElem);
          preCaretRange.setEnd(range.endContainer, range.endOffset);
          currentPos = preCaretRange.toString().length;
        }

        return currentPos;
      }

      function setCursorAtNodePosition(node, position) {
        let range = document.createRange();
        let selection = window.getSelection();
        let currentPos = 0;
        let found = false;

        function searchNode(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            if (currentPos + node.length >= position) {
              range.setStart(node, position - currentPos);
              range.collapse(true);
              found = true;
            } else {
              currentPos += node.length;
            }
          } else {
            for (let child of node.childNodes) {
              if (found) break;
              searchNode(child);
            }
          }
        }
        searchNode(node);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    </script>
  </body>
</html>
